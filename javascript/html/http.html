<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body>
    <script>
      // 浏览器地址栏输入url到显示页面的步骤(以HTTP为例)
      // 1. DNS(Domain Name System域名系统) 解析（将网址解析为 IP地址）
      // www.pic.baidu.com  com 是顶级域名，baidu 是二级域名， pic是三级域名

      // 用户主机上运行着DNS的客户端，浏览器将 主机名 传送给 DNS应用 的客户端，

      // DNS 客户机端向 DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段
      // 该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址

      // 一旦该浏览器收到来自 DNS的 IP地址，就可以向该 IP地址定位的 HTTP服务器发起 TCP连接
      // 浏览器   DNS   web服务器
      // 2.TCP连接
      // 三次握手: 客户端 '发起' 链接，服务器 '创建' 连接，客户端向服务器 '确认' 链接
      // 3.发送 HTTP请求（get post）
      // HTTP的 报文格式 主要分为： 报文首部 空行 报文主体  （实体首部，实体主体）
      // 请求报文：请求行，请求头，空行，请求体； 响应报文：状态行，响应头，空行，响应体
      // 请求头：请求首部字段，通用首部字段，实体首部字段； 响应头：响应首部字段，通用首部字段，实体首部字段；
      // 通用首部字段：
      // 请求首部字段：
      // 响应首部字段：

      // accept encoding：请求内容的压缩方式， content encoding：响应内容的压缩方式
      // connection：keep-alive  TCP建立持久化链接  通用首部
      // cache-control 缓存，通用首部：请求报文 和 响应报文都会用到的  max-age 604800 内容在本地最长缓存时间为 7 天。 7天内的内容访问都是从缓存中读取的！！
      // public 可以被任何对象缓存， private 只被发出请求的用户缓存
      // Last-Modified 和 ETag 的作用是相同的（均为向服务器验证资源是否最新）
      // Accept 请求头用来告知 客户端 可以处理的 内容类型
      // Accept-Charset 请求头用来告知（服务器）客户端 可以处理的 字符集类型
      // Accept-Encoding 会将客户端 能够理解 的内容编码方式——通常是某种 压缩算法 ——进行通知
      // Age 消息头里包含 消息对象 在 缓存代理 中存贮的时长，以秒为单位
      // 4.服务器处理请求并返回 HTTP 报文
      // 因为服务器需要应对多浏览器的并发访问，所以设计时，在发送 响应报文 和 内容 时，不保存 浏览器请求 的任何状态信息，所以称http 是无状态的。

      // 5.浏览器接收html,css,js并解析渲染页面
      // 6.连接结束
      //  答案：https://github.com/qiu-deqing/FE-interview#%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9Bseo
      // HTTP是一种协议; 这个协议规定了：计算机之间 通过http请求 进行数据交换的规则; 这里的数据一般指的是 html文档
      // 一个http请求 --- https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Identifying_resources_on_the_Web
      // 由客户端（浏览器）发出的 HTTP消息 叫做 requests（请求）,  然后由（服务器端）回应的 HTTP消息 叫做  responses（响应）
      // 在 client 与server之间，还有许许多多的被称为proxies（代理服务器）的实体（包括计算机、路由器、调制解调器等等）

      // schema://host[:port#]/path/.../[?query-string][#anchor]

      // url --- 统一资源定位符  “http://” 告诉浏览器使用何种协议
      // 网页渲染的流程：浏览器发出 http消息 并返回 HTTP请求 获取html，再根据html内容发出其他 http消息 并返回 HTTP请求 获取css js img
      // （请求的所有资源都在服务端, web 服务器可以是 计算机硬件， 也可以是软件,
      // 一个服务器不一定是一个独立的 物理机 ：几台 服务器 可以驻留在同一台 物理机器 上，或者一台服务器可以通过几台机器进行处理）
      // 最后将这些内容结合到一起，展现出来一个完整的文档，也就是网页。

      // HTTP的头部扩展 (HTTP Cookies --- 创建一个会话来让每次请求都能共享相同的上下文信息，相同的状态)
      // 一个连接是由传输层来控制的 ---TCP
      // 用户代理 --- 通常，用户代理是指一个浏览器

      // 获取 url 的各个字段：
      // 例子：URL：http://b.a.com:88/index.php?name=kang&when=2011#first
      //    属性      	含义	                     值
      // protocol:	协议	                     "http:" 除此还有 https ftp  大小写没有关系
      // hostname:	域名(服务器的名字)	            "b.a.com"  相当于服务器的 IP 地址，用域名只是为了方便访问
      // port:	    端口	                      "88"  即通过 IP 先找到 物理服务器，再根据端口找到 web服务器，原理解释在如下：
      // 一台拥有IP地址的主机可以提供许多服 务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来 实现。
      // 那么，主机是怎样 区分 不同的 网络服务 呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区 分不同的服务的
      // pathname:	路径(URL中主机名后的部分)     	"/index.php"   即服务器中资源的地址  get post 请求的地址只需要写上 路径地址即可
      // search:	查询字符串/请求参数 ("?"后的部分)	"   ?name=kang&when=2011"
      // hash:	片段标识符(返回"#"之后的内容,后面的任何字符都不会被发送到服务器)	            "#first"
      // host:	等于hostname + port	        "b.a.com:88"
      // href:	当前页面的完整URL            	"http://www.a.com:88/index.php?name=kang&when=2011#first"

      // http报文： 请求报文：request headers   响应报文：response  headers
      //  csp  content-security-policy 内容安全策略，在返回的响应中生成
      //    http所有请求方法：各种方法的区别只是语义上的，
      //    GET,  从服务器获取一份文档
      //    POST, 向服务器发送需要处理的数据
      //    HEAD, 返回请求资源的首部信息，使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.
      //    OPTIONS, 用于获取 当前URL 所支持的方法,响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法
      //    PUT,  将请求的主体部分存储在服务器上
      //    DELETE, 从服务器上删除一份文档
      //    TRACE, 追踪 经过 代理服务器 上传到 服务器的请求报文
      //    CONNECT,
      //    PATCH, 用于对资源进行部分修改
      //    GET POST PUT DELETE  查 改 增 删

      // hash
      // history API

      // route 是指根据 url 分配到对应的 处理程序
      // 前端路由：客户端不依赖服务端， 根据不同的 url 渲染 不同的 视图页面。

      // 前端路由实现方式：
      // 在页面不刷新的前提下实现url变化; 捕捉到url的变化，以便执行页面替换逻辑
      // [实现方式]：
      // 1. hash 字段； 通过 hashChange 事件 执行页面展示逻辑
      // 2. history API； 通过 history.back() history.forward() 触发 popstate事件，然后执行页面替换逻辑
      // history.replaceState(dataObj, title, url);
      // history.pushState(dataObj, title, url);

      // DOM window 对象通过 history 对象提供了对浏览器历史的访问：
      // history.go()  history.back() history.forward() history.replaceState() history.pushState(）

      //

      // 域名：
      // 域名的本质是 IP 地址的别名，不带 www 的是根域名，也就是一级域名~~，不过国际统一默认www 是根域名，其实也是二级域名~
      // 在以前，浏览器并不会识别域名下的服务是什么种类的，所以，加上 www 可以告诉浏览器，这是个网站
      // 而现在，我们看到的 URL 常常是 http://w3cfun.com/ , ftp://w3cfun.com/ 等
      // 此时我们已经在 URL 中标记了服务的类型是 HTTP 或者 FTP. 这样，我们就没有必要再指定子域名了
      // 不管是否使用 www，做一个 301跳转，
      // http://www.example.com/foo/bar?spam=egg 跳转到 http://example.com/foo/bar?spam=egg 相反，同样的意思，这样的跳转需要在 web 服务器里单独配置
      // URI（统一资源标识符）--- 想当于通过 身份证查找一个人。 URI 有两种形式： URL 和 URN
      // URL（统一资源定位符）--- 相当于通过 一个地址查找某个人。 描述了一台 特定服务器 上某资源的 特定位置
      // URN （统一资源名）--- 如果使用URN，那么资源的地址再怎么变，永远都可以通过URN来获取这个资源

      // 所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而 URL 就是用定位的方式实现的URI。

      // sdk --- 软件开发工具包
      // CORS (cross-origin sharing standard) --- 跨域资源共享 允许web服务器进行跨域访问控制，浏览器支持使用cros。 cros需要客户端和服务器端同时支持。 所有浏览器都支持 cros
      // http首部字段 --- 允许 服务器声明 哪些源站有权访问哪些资源
      // 浏览器限制跨域请求
      // 浏览器端 ---  预检请求获知服务器是否允许跨域请求
      // XMLHttpRequest对象发起跨域请求
      // 简单请求   预检请求--- 需要 OPTTIONS方法获知服务器是否允许该实际请求
      // 预检请求 完成后 才发送实际请求

      // 附带身份凭证的请求
      // HTTP请求首部字段
      // HTTP响应首部字段
      // http的原始消息 由浏览器，软件，服务器完成
      // http 发送请求前会在 底层传输层 建立一条TCP连接。。
      // http1.1 后 在请求发送后 链接 不再断开，从而可以连续发送请求和响应。。 HTTP流水线模式 更先进些，多个请求不用等待返回即可被发送
      // 即开始的短线模式（请求一次断开） 到 长线模式（一次链接多个请求） 到 （一次链接多个请求无需等待发送）
      // HTTP1.1里， 默认就是长链接。 协议头不再去声明它。
      // HTTP2 能够很好的处理 并发的无优先级 的请求。
      // http 请求头 access-control-allow -headers
      // http 请求方法  get  post  put（修改资源）  delete  它们用来定义对资源的操4作，它们的区别在于语义化，可以通过不同的方法来实现想要的功能
      // http 状态返回码 --- 1** 已经收到消息；2** 正常返回信息；3** 请求需要重定向，4** 客户端请求错误，5** 服务器端错误 .。。
      // HTTP协议对参数长度也没限制，大多数和服务器容器的配置有关

      // 互联网的核心是一系列协议， 它们对电脑如何连接和组网，做出了详尽的规定。
      // 1. 实体层： 光纤，光缆(传送 0和1的电信号)

      // 2. 数据链路层： 以太网协议（确定了 0和1的分组方式） 用来处理连接网络的硬件部分。。  (功能是发送 数据包)
      // 广播方式：以太网规定，“一组电信号” 构成 "一个数据包"，每个 "数据包" 由 标头和数据 构成。
      // "数据包" 必须是从一块网卡，传送到另一块网卡。网卡的地址，就是 "数据包" 的发送地址和接收地址，这叫做MAC地址
      // （在知道接收方MAC地址的前提下 ARP协议）向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方，若发送的Mac地址和接收方的Mac地址相同，则接收这个 包。否则丢弃！

      // 3. 网络层： IP(Internet Protocol) 协议（传送二进制数据）用来处理在网络上流动的 '数据包'
      // 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线

      // 网络层引进一套新的地址，使得我们能够 "区分" 不同的计算机是否属于同一个子网络。这套地址就叫做"网络地址"，简称"网址"
      // 如果是同一个子网络，就采用 '广播方式' 发送，否则就采用"路由"方式发送
      // MAC地址 --- 是绑定在 “网卡” 上的，作用是将 “数据包” 送到该 '子网络' 中的目标网卡   网络地址（IP） --- 则是管理员分配的，它们只是随机组合在一起,作用是确定计算机所在的子网络
      // 因此，从逻辑上可以推断，必定是先处理 '网络(IP)地址'，然后再处理 'MAC地址'

      // 4. 传输层： TCP(Transmission Control Protocol) 协议（传送文本）  UDP(User Data Protocol)
      // 将大块数据分割成以报文段（segment）为单位的 '数据包' , 我们还需要一个参数，表示这个 '数据包' 到底供哪个程序（进程）使用。这个参数就叫做"端口"（port），
      // 不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的 相应端口 联系,
      // 在 “数据包” 中加入端口信息,需要UDP协议（UDP数据包）（无法确认对方是否接收到 包）/ TCP协议 (TCP数据包)
      // "传输层"的功能，就是建立"端口到端口"的通信。相比之下，"网络层"的功能是建立"主机到主机"的通信。只要确定主机和端口，我们就能实现程序之间的交流。
      // 因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。

      // 5. 应用层： http(HyperText Transfer protocol) 协议  FTP(File Transfer Protocol)  DNS(Domain Name System) ...
      // "应用层"的作用，就是规定 应用程序 的数据格式,即规定 '数据包' 以相应的格式显示。。

      // 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。 '发送端' 从应用层往下走，接收端 则往 '应用层' 往上走
      // '发送端' 在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。
      // 反之，'接收端' 在层与层传输数据时，每经过一层时会把对应的首部消去
      // 论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。
      // 三次握手(HTTP请求链接前) ---  发送端首先发送一个带 SYN(synchronize) 标志的 '数据包' 给对方。接收端收到后，回传一个带有 SYN/ACK 标志的 '数据包' 以示传达确认信息。
      // 最后，发送端再回传一个带 ACK(acknowledgement) 标志的 '数据包' ，代表“握手”结束

      // TCP/IP 笔记
      // 网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）, IP地址是网络号+主机号的组合
      // 域名系统(DNS) 是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。需要用到域名服务器
      // RFC就是tcp/ip协议的标准文档
      // 端口号 --- 这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口

      // curl 是一种命令行工具，作用是发出网络请求，然后得到和提取数据，
      // curl -v `-v`参数可以显示一次http通信的整个过程，包括端口连接和http request头信息

      // 在网络中 Ping 是一个十分好用的TCP/IP工具。它主要的功能是用来 测网络的连通情况 和 分析网络速度
    </script>
  </body>
</html>
